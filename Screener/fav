import pandas as pd
import numpy as np
import yfinance as yf
from plotly.subplots import make_subplots
import plotly.graph_objects as go
from datetime import datetime

# --- Indicadores t√©cnicos principais ---
def calcular_indicadores(df, length=20, momentum_threshold=0.07):
    df = df.dropna(subset=['Open', 'High', 'Low', 'Close'])
    df = df[(df['High'] > df['Low']) & (df['Open'] != df['Close'])]
    df['High20'] = df['High'].rolling(length).max().shift(1)
    df['Low20'] = df['Low'].rolling(length).min()
    df['SMA20'] = df['Close'].rolling(20).mean()
    df['SMA50'] = df['Close'].rolling(50).mean()
    df['SMA150'] = df['Close'].rolling(150).mean()
    df['SMA200'] = df['Close'].rolling(200).mean()
    df['EMA20'] = df['Close'].ewm(span=20, adjust=False).mean()
    centro = ((df['High20'] + df['Low20']) / 2 + df['Close'].rolling(length).mean()) / 2
    df['linreg_close'] = df['Close'].rolling(length).apply(lambda x: np.polyfit(np.arange(length), x, 1)[1] + np.polyfit(np.arange(length), x, 1)[0] * (length - 1), raw=True)
    df['momentum'] = df['linreg_close'] - centro
    df['momentum_up'] = (df['momentum'].shift(1) <= 0) & (df['momentum'] > momentum_threshold)
    df['rompe_resistencia'] = df['Close'] > df['High20']
    df['suporte'] = df['Low'].rolling(length).min()
    return df

# --- RS Rating ---
def calcular_rs_rating(df_ativo, df_bench):
    df_ativo = df_ativo.sort_index().copy()
    df_bench = df_bench.sort_index().copy()

    def calc_perf(df, dias):
        if len(df) > dias:
            return df['Close'].iloc[-1] / df['Close'].iloc[-dias]
        else:
            return np.nan

    perf_ativo = {k: calc_perf(df_ativo, int(k)) for k in ["63", "126", "189", "252"]}
    perf_bench = {k: calc_perf(df_bench, int(k)) for k in ["63", "126", "189", "252"]}

    if any(np.isnan(list(perf_ativo.values()))) or any(np.isnan(list(perf_bench.values()))):
        return None

    rs_stock = 0.4 * perf_ativo["63"] + 0.2 * perf_ativo["126"] + 0.2 * perf_ativo["189"] + 0.2 * perf_ativo["252"]
    rs_ref = 0.4 * perf_bench["63"] + 0.2 * perf_bench["126"] + 0.2 * perf_bench["189"] + 0.2 * perf_bench["252"]
    total_rs_score = (rs_stock / rs_ref) * 100

    thresholds = [
        (195.93, 99), (117.11, 90), (99.04, 70),
        (91.66, 50), (80.96, 30), (53.64, 10), (24.86, 1)
    ]

    for i in range(len(thresholds) - 1):
        upper, rating_upper = thresholds[i]
        lower, rating_lower = thresholds[i + 1]
        if lower <= total_rs_score < upper:
            return round(rating_lower + (rating_upper - rating_lower) * (total_rs_score - lower) / (upper - lower))

    return 99 if total_rs_score >= thresholds[0][0] else 1

# --- Earnings info detalhado ---
def get_earnings_info_detalhado(ticker):
    try:
        ticker_obj = yf.Ticker(ticker)
        calendar = ticker_obj.calendar
        if isinstance(calendar, dict) or isinstance(calendar, pd.Series):
            earnings = calendar.get("Earnings Date", None)
            if isinstance(earnings, list) and earnings:
                earnings = earnings[0]
            if isinstance(earnings, (pd.Timestamp, datetime, pd.Timestamp.date)):
                earnings_date = pd.to_datetime(earnings).tz_localize("America/New_York") if pd.to_datetime(earnings).tzinfo is None else pd.to_datetime(earnings)
                now = pd.Timestamp.now(tz="America/New_York")
                delta = (earnings_date - now).days
                data_str = earnings_date.strftime('%d %b %Y')
                if delta >= 0:
                    return f"{data_str} (em {delta}d)", earnings_date, delta
                else:
                    return f"√öltimo: {data_str} (h√° {-delta}d)", earnings_date, delta
        return "Indispon√≠vel", None, None
    except Exception:
        return "Erro", None, None

# --- VCP ---
def detectar_vcp(df):
    if 'Volume' not in df.columns or len(df) < 40:
        return False
    closes = df['Close']
    highs = df['High']
    lows = df['Low']
    volumes = df['Volume']
    sma50 = closes.rolling(50).mean()
    max1 = highs[-40:-20].max()
    max2 = highs[-20:].max()
    if pd.isna(max1) or pd.isna(max2) or not (max1 > max2): return False
    min1 = lows[-40:-20].min()
    min2 = lows[-20:].min()
    if pd.isna(min1) or pd.isna(min2) or not (min1 < min2): return False
    vol_ant = volumes[-40:-20].mean()
    vol_rec = volumes[-20:].mean()
    if pd.isna(vol_ant) or pd.isna(vol_rec) or not (vol_ant > vol_rec): return False
    range_ant = (highs[-40:-20] - lows[-40:-20]).mean()
    range_rec = (highs[-20:] - lows[-20:]).mean()
    if pd.isna(range_ant) or pd.isna(range_rec) or not (range_ant > range_rec): return False
    if pd.isna(sma50.iloc[-1]) or closes.iloc[-1] < sma50.iloc[-1] * 0.97: return False
    return True

# --- Risco ---
def avaliar_risco(df):
    preco_atual = df['Close'].iloc[-1]
    suporte = df['Low'].rolling(20).min().iloc[-1]
    resistencia = df['High'].rolling(20).max().iloc[-1]
    risco = 5
    df['TR'] = np.maximum(df['High'] - df['Low'], np.maximum(abs(df['High'] - df['Close'].shift(1)), abs(df['Low'] - df['Close'].shift(1))))
    atr = df['TR'].rolling(14).mean().iloc[-1]
    if atr / preco_atual > 0.05: risco += 1
    else: risco -= 1
    if (preco_atual - suporte) / preco_atual > 0.05: risco += 1
    if (resistencia - preco_atual) / preco_atual < 0.03: risco += 1
    if preco_atual < df['SMA200'].iloc[-1]: risco += 1
    quedas = sum(df['Close'].tail(30).diff() < 0)
    if quedas >= 3: risco += 1
    media_volume = df['Volume'].tail(30).mean()
    dias_queda_vol = df.tail(30)[(df['Close'] < df['Close'].shift(1)) & (df['Volume'] > media_volume)]
    if not dias_queda_vol.empty: risco += 1
    if df['rompe_resistencia'].iloc[-1] and df['Volume'].iloc[-1] > df['Volume'].rolling(20).mean().iloc[-1]: risco -= 1
    if df['EMA20'].iloc[-1] > df['SMA50'].iloc[-1] > df['SMA150'].iloc[-1] > df['SMA200'].iloc[-1]: risco -= 1
    return int(min(max(round(risco), 1), 10))

# --- Tend√™ncia (usada para an√°lises visuais e IA) ---
def classificar_tendencia(close):
    x = np.arange(len(close))
    slope, _ = np.polyfit(x, close, 1)
    if slope > 0.05: return "Alta"
    elif slope < -0.05: return "Baixa"
    return "Lateral"

# --- Coment√°rio t√©cnico resumido ---
def gerar_comentario(df, risco, tendencia, vcp):
    comentario = "üìä Ativo em zona de observa√ß√£o t√©cnica"
    sinais = []
    if df['momentum_up'].iloc[-1]: sinais.append("Momentum")
    if df['rompe_resistencia'].iloc[-1]: sinais.append("Rompimento")
    if vcp: sinais.append("Padr√£o VCP")
    if sinais:
        comentario += f"\nüìà Sinais t√©cnicos: {', '.join(sinais)}"
    return comentario

# --- Pivot Points ---
def calcular_pivot_points(df):
    high = df['High'].iloc[-2]
    low = df['Low'].iloc[-2]
    close = df['Close'].iloc[-2]
    PP = (high + low + close) / 3
    R1 = 2 * PP - low
    S1 = 2 * PP - high
    R2 = PP + (R1 - S1)
    S2 = PP - (R1 - S1)
    R3 = high + 2 * (PP - low)
    S3 = low - 2 * (high - PP)
    return PP, [S1, S2, S3], [R1, R2, R3]

# --- Crescimento YoY via yfinance ---
def get_quarterly_growth_table_yfinance(ticker):
    ticker_obj = yf.Ticker(ticker)
    df = ticker_obj.quarterly_financials.T
    if df.empty or "Total Revenue" not in df.columns or "Net Income" not in df.columns:
        return None
    df = df[["Total Revenue", "Net Income"]].dropna().sort_index(ascending=False)
    rows = []
    for i in range(5):
        try:
            atual = df.iloc[i]
            trimestre_data = df.index[i].date()
            receita_atual = atual["Total Revenue"]
            lucro_atual = atual["Net Income"]
            receita_pct = lucro_pct = None
            if i + 4 < len(df):
                receita_ant = df.iloc[i + 4]["Total Revenue"]
                lucro_ant = df.iloc[i + 4]["Net Income"]
                if receita_ant:
                    receita_pct = (receita_atual - receita_ant) / receita_ant * 100
                if lucro_ant:
                    lucro_pct = (lucro_atual - lucro_ant) / abs(lucro_ant) * 100
            margem = (lucro_atual / receita_atual) * 100 if receita_atual else None
            def fmt_pct(val):
                if val is None: return ""
                emoji = " üöÄ" if val > 18 else ""
                return f"{val:+.1f}%{emoji}"
            rows.append({
                "Trimestre": trimestre_data.strftime("%b %Y"),
                "Receita (B)": f"${receita_atual / 1e9:.2f}B",
                "Receita YoY": fmt_pct(receita_pct),
                "Lucro (B)": f"${lucro_atual / 1e9:.2f}B",
                "Lucro YoY": fmt_pct(lucro_pct),
                "Margem (%)": f"{margem:.1f}%" if margem is not None else ""
            })
        except Exception:
            continue
    return pd.DataFrame(rows).set_index("Trimestre")

# --- Estilo visual para tabela de n√≠veis ---
def highlight_niveis(row):
    nivel = row.name
    if "Pre√ßo Atual" in nivel:
        return ["background-color: #fff3b0; font-weight: bold;"] * len(row)
    elif "üî∫" in nivel:
        return ["color: #1f77b4; font-weight: bold;"] * len(row)
    elif "üîª" in nivel:
        return ["color: #2ca02c; font-weight: bold;"] * len(row)
    elif any(tag in nivel for tag in ["üü£", "üìè", "üìà", "üìâ"]):
        return ["color: #9467bd; font-style: italic;"] * len(row)
    return [""] * len(row)

# --- Inserir pre√ßo atual no meio da tabela de suportes/resist√™ncias ---
def inserir_preco_no_meio(niveis, preco):
    df = pd.DataFrame(niveis)
    df_preco = pd.DataFrame([{"N√≠vel": "Pre√ßo Atual", "Valor": preco}])
    idx = next((i for i, r in enumerate(niveis) if r["Valor"] < preco), len(niveis))
    df_final = pd.concat([df.iloc[:idx], df_preco, df.iloc[idx:]]).reset_index(drop=True)
    return df_final

# --- Cache do SPY ---
@st.cache_data(ttl=3600)
def carregar_spy():
    df_spy = yf.download('^GSPC', period="18mo", interval="1d", progress=False)
    if df_spy is not None and not df_spy.empty:
        if isinstance(df_spy.columns, pd.MultiIndex):
            df_spy.columns = df_spy.columns.droplevel(1)
        return df_spy
    else:
        return None